# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

### Ответ
```
Чтобы узнать opid длительного запроса, выполнить запрос
> db.currentOp()


Пример для поиска активного запроса, длительностью более 3 минут:
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 }
   }
)

Далее можно его остановить:
> db.killOp(<opid>)

```

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
### Ответ
```
С помощью профилирования найти долгие запросы
Прмер включения профилирования для запросов, длительностью более 20 мс
> db.setProfilingLevel(1, { slowms: 20 })

При помощи db.system.profile можно находить долгие запросы
При помощи методов EXPLAIN понять причины долгого выполнения. 
Начать с оптимизаци индексов:
добавить необходимые, удалить неиспользуемые. 
```

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?


### Ответ
```
Блокировка может наступить из-за большого количества одновременно истекших ключей.
Если в одну секунду истекает большое количество ключей и их количество превышает 25% от набора истекших ключей,
redis может блокировать операции для снижения числа процента истекших ключей до значения меньше 25%.
```
 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query/readme.md:1 u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?
### Ответ
```
Вероятные причины возникновения ошибки:
- сетевые проблемы
- клиент не может установить соединение с БД
- Наиболее вероятная: возвращается очень большое количество строк
```

Какие пути решения данной проблемы вы можете предложить?

```
Исключить сетевые проблемы.
Изменить (оптимизировать) запрос, сократить возращаемый набор данных
Изменить параметр  net_read_timeout (по умолчанию: 30 сек) до 60 сек или больше.
Рассмотреть вариант перехода на БД, более подходящую для гис-систем. Напр., PostGis.
```

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

### Ответ
```
Данное сообщение указывает на нехватку памяти
```

### Ответ
Как бы вы решили данную проблему?
```
- Не запускать на сервере Postgresql никакие дополнительные сервисы (кроме необходимым для администрирования/управления/мониторинга и т.п.)
- Запретит overcommit памяти на сервере:
sysctl -w vm.overcommit_memory=2 либо изменить данное значение в /etc/sysctl.conf

- Изменить конфигурацию параметров: shared_buffers, work_mem, и hash_mem_multiplier.
- Проверить коннекты к БД, сократить  max_connections - большое количество коннектов, либо их незакрытие со стороны клиентов, может быть причиной OOM killer.
```